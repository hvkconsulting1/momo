# Story 1.4: Build Data Quality Validation Pipeline

## Status

**Draft**

## Story

**As a** developer,
**I want** automated data quality checks for missing prices, corporate actions, and point-in-time constituents,
**so that** backtest integrity is ensured and survivorship bias is eliminated.

## Acceptance Criteria

1. `src/data/validation.py` module implements data quality check functions
2. Validation detects missing price data (NaN or gaps in expected date ranges) and reports affected tickers
3. Validation checks for adjustment factor consistency (splits/dividends properly applied)
4. Function retrieves point-in-time index constituents for a specified date using Norgate API (e.g., Russell 1000 Current & Past constituents as of 2010-01-01)
5. Delisting data is accessible and can be queried to identify when tickers were removed from the universe
6. Validation report summarizes: total tickers, date range, missing data counts, delisting events
7. Tests verify validation functions correctly identify synthetic missing data and corporate action issues
8. Documentation explains how to interpret validation reports and handle common data quality issues

## Tasks / Subtasks

- [ ] Implement data quality validation module (AC: 1, 2, 3, 6, 7)
  - [x] Add `ValidationError` exception class to `src/momo/utils/exceptions.py` (subclass of `DataError`)
  - [x] Create `src/momo/data/validation.py` module
  - [x] Implement `ValidationReport` dataclass with fields: total_tickers, date_range, missing_data_counts, delisting_events, adjustment_issues, summary_message
  - [x] Implement `validate_prices()` function to detect missing price data (NaN values, gaps in expected date ranges)
  - [x] Implement `_check_missing_values()` helper to identify tickers with NaN/null values in critical columns (open, high, low, close)
  - [ ] Implement `_check_date_gaps()` helper to detect unexpected gaps in time series for each ticker
  - [ ] Implement `_check_adjustment_consistency()` helper to validate adjustment factors (split/dividend application)
  - [x] Implement validation report generation with summary statistics
  - [x] Add type hints to all validation functions
  - [x] Document DataFrame schemas and validation logic in docstrings

- [ ] Implement point-in-time index constituent retrieval (AC: 4, 5, 6)
  - [ ] Add `get_index_constituents_at_date()` function to retrieve index membership for specific date
  - [ ] Use bridge to call `norgatedata.index_constituent_timeseries()` via Windows Python
  - [ ] Implement `check_delisting_status()` function to identify when tickers were delisted
  - [ ] Add delisting information to validation reports
  - [ ] Handle edge cases: stocks not in index, invalid index names, date out of range
  - [ ] Add comprehensive error handling with custom exceptions from `momo.utils.exceptions`

- [ ] Write unit tests for validation functions (AC: 7)
  - [x] Create test directory `tests/stories/1.4/unit/`
  - [x] Create story-level conftest.py with shared fixtures
  - [x] Write unit test for `validate_prices()` with clean data (no issues detected)
  - [x] Write unit test for `validate_prices()` detecting NaN values in price columns
  - [ ] Write unit test for `validate_prices()` detecting date gaps
  - [ ] Write unit test for `_check_adjustment_consistency()` with synthetic adjustment issues
  - [ ] Write unit test for `get_index_constituents_at_date()` with mock bridge responses
  - [ ] Write unit test for `check_delisting_status()` with known delisted ticker
  - [x] Add required pytest markers (@pytest.mark.p0/p1/p2 and @pytest.mark.unit) to all test functions
  - [x] Ensure all tests follow story-based test organization (one test per file)

- [ ] Write integration tests for validation pipeline (AC: 7)
  - [ ] Create test directory `tests/stories/1.4/integration/`
  - [ ] Write integration test for full validation pipeline with cached test data
  - [ ] Write integration test for point-in-time constituent retrieval via bridge (may require NDU)
  - [ ] Write integration test for delisting data retrieval and validation reporting
  - [ ] Add required pytest markers (@pytest.mark.p0/p1/p2 and @pytest.mark.integration) to all test functions
  - [ ] Ensure integration tests can run with mock data when NDU unavailable

- [ ] Add documentation for validation module (AC: 8)
  - [ ] Document ValidationReport structure and interpretation in docstrings
  - [ ] Add usage examples in module docstring
  - [ ] Document common data quality issues and remediation strategies
  - [ ] Explain how to interpret validation report fields (missing_data_counts, adjustment_issues, etc.)

## Dev Notes

### Previous Story Insights

**Story 1.3 Key Learnings:**
- Schema validation pattern (`_validate_price_schema()`) with 5 distinct checks proved highly effective - reuse similar pattern for validation.py
- Comprehensive docstrings with DataFrame schema specifications are critical (mypy strict mode requires this)
- Graceful partial failure handling with error aggregation via structlog was essential for robustness - apply same pattern to validation functions
- Always use `df.copy()` before modifying DataFrames to maintain immutability (ADR-004 pure functions requirement)
- PyArrow engine for Parquet I/O ensures MultiIndex preservation
- Integration tests requiring NDU should be marked appropriately for CI skip capability

### Architecture Context

**Layer:** Data Layer (`src/momo/data/`)
[Source: architecture/high-level-architecture.md#layered-pipeline-architecture]

**Dependencies:**
- This module depends on Story 1.2 bridge (`src/momo/data/bridge.py`) and Story 1.3 cache/loader (`src/momo/data/cache.py`, `src/momo/data/loader.py`)
- Must follow unidirectional data flow: Data → Signal → Portfolio → Backtest
- No dependencies on upper layers allowed
[Source: architecture/high-level-architecture.md#architectural-patterns]

### Data Models

**Price Data Schema** (input to validation functions):
[Source: architecture/data-models.md#price-data]
- MultiIndex: `(date, symbol)` where date is `datetime64[ns]`, symbol is `str`
- Required columns:
  - `open`, `high`, `low`, `close`, `unadjusted_close`: `float64`
  - `volume`: `int64`
  - `dividend`: `float64`
- This is the schema produced by Story 1.3 loader - validation.py must accept this format

**Universe Constituents Schema** (for point-in-time constituent checks):
[Source: architecture/data-models.md#universe-constituents]
- Index: `date` (`datetime64[ns]`)
- Columns:
  - `symbol`: `str`
  - `index_name`: `str` (e.g., "S&P 500", "Russell 1000 Current & Past")
  - `is_member`: `bool` (True if symbol was index member on date)

**ValidationReport Dataclass** (output structure):
Define in `validation.py` with fields:
```python
@dataclass
class ValidationReport:
    total_tickers: int
    date_range: tuple[datetime.date, datetime.date]
    missing_data_counts: dict[str, int]  # ticker -> count of missing values
    date_gaps: dict[str, list[tuple[datetime.date, datetime.date]]]  # ticker -> list of gap ranges
    adjustment_issues: list[str]  # list of tickers with suspected adjustment problems
    delisting_events: dict[str, datetime.date | None]  # ticker -> delisting date (None if not delisted)
    summary_message: str
    is_valid: bool  # True if no critical issues found
```

### Norgate API Integration

**Index Constituent Retrieval:**
[Source: architecture/external-apis.md#norgate-data-api]
Use `norgatedata.index_constituent_timeseries(symbol, index)` via Windows Python bridge:
- Returns point-in-time index membership (0/1 time series)
- Use with indexes like "S&P 500", "Russell 1000", etc.
- Must call via bridge.py since Norgate is Windows-only
- Use `PaddingType.NONE` to avoid forward-filling delisted securities

**Bridge Integration Pattern:**
[Source: architecture/components.md#windows-python-bridge]
All Norgate calls must go through `src/momo/data/bridge.py`:
```python
from momo.data.bridge import fetch_price_data  # for price data
# For constituent data, may need to add bridge function or use execute_norgate_code()
```

**Error Handling for Bridge Calls:**
[Source: architecture/error-handling-strategy.md#error-handling-patterns]
- 3 retry attempts with exponential backoff (1s, 2s, 4s)
- 30s timeout per symbol, 300s for full universe
- Translate bridge errors to `BridgeError` or `NDUNotRunningError` from `momo.utils.exceptions`
- Use structlog for error logging with context (symbol, operation, layer)

### File Locations

**Source Files:**
[Source: architecture/source-tree.md]
- Create: `src/momo/data/validation.py`
- Import from: `src/momo/data/bridge.py` (Story 1.2), `src/momo/data/cache.py` (Story 1.3)
- Import exceptions from: `src/momo/utils/exceptions.py`

**Test Files:**
[Source: architecture/test-strategy-and-standards.md#directory-structure]
- Unit tests: `tests/stories/1.4/unit/test_1_4_unit_{seq}.py`
- Integration tests: `tests/stories/1.4/integration/test_1_4_int_{seq}.py`
- Story fixtures: `tests/stories/1.4/conftest.py` (create if needed for shared test data)
- **CRITICAL**: One test ID per file (deterministic AI agent mapping)

**Test File Naming Convention:**
[Source: architecture/coding-standards.md#naming-conventions]
- Pattern: `test_{story_id}_{level}_{seq}.py`
- Examples: `test_1_4_unit_001.py`, `test_1_4_int_005.py`
- Test function naming: `test_1_4_unit_001()` (primary function matching test ID)

### Testing Requirements

**Test Organization:**
[Source: architecture/test-strategy-and-standards.md#story-based-test-organization]
- Use story-based test organization: `tests/stories/1.4/{unit,integration}/`
- One test per file for zero merge conflicts with parallel agents
- Each test file must contain test ID in docstring with Story, Priority, Test Level, Risk Coverage

**Required Pytest Markers:**
[Source: CLAUDE.md#story-based-test-organization]
ALL test functions MUST have both markers:
```python
@pytest.mark.p0  # or p1, p2 based on priority
@pytest.mark.unit  # or integration based on test level
def test_1_4_unit_001():
    ...
```

**Priority Guidelines:**
- **P0:** Critical path validation functions (validate_prices, missing data detection)
- **P1:** Important validation logic (adjustment consistency, delisting checks)
- **P2:** Edge cases and documentation tests

**Test Pyramid Target:**
[Source: architecture/test-strategy-and-standards.md#testing-philosophy]
- 70% unit tests (isolated, mocked I/O, < 100ms execution)
- 25% integration tests (real bridge calls if NDU available, < 5s execution)
- Mock bridge responses in unit tests, real bridge calls in integration tests

**Fixture Strategy:**
[Source: architecture/test-strategy-and-standards.md#fixture-management]
1. Global fixtures from `tests/conftest.py` (project_root, data_dir)
2. Story fixtures in `tests/stories/1.4/conftest.py` (sample validation data, mock reports)
3. Test-specific fixtures inline in test file (unique edge cases)

### Type Checking & Code Quality

**Type Hints:**
[Source: architecture/coding-standards.md#critical-rules]
- Strict mypy mode required - all functions must have complete type annotations
- Use `from __future__ import annotations` for forward references
- DataFrame parameters: `pd.DataFrame` (document schema in docstring)
- Return types must be explicit: `ValidationReport`, `pd.DataFrame | None`, etc.

**Naming Conventions:**
[Source: architecture/coding-standards.md#naming-conventions]
- DataFrame variables: suffix `_df` (e.g., `prices_df`, `constituents_df`)
- Date variables: suffix `_date` (e.g., `start_date`, `delisting_date`)
- Use `datetime.date` explicitly, not strings
- Private helper functions: prefix `_` (e.g., `_check_missing_values()`)

**Logging:**
[Source: architecture/coding-standards.md#critical-rules]
- Use structlog exclusively (never `print()` or stdlib `logging`)
- Include context: layer="data", operation="validate_prices", symbol="AAPL"
- Log levels: INFO for validation start/complete, WARNING for data issues, ERROR for failures

**DataFrame Immutability:**
[Source: CLAUDE.md#pure-functions-in-core-layers]
- Data layer validation functions are NOT required to be pure (I/O allowed)
- However, if modifying DataFrames for analysis, use `df.copy()` to avoid mutation
- Return new DataFrames/objects; don't modify inputs in-place

### Validation Logic Specifications

**Missing Data Detection:**
1. Check for NaN/null values in required columns: open, high, low, close
2. Identify tickers with missing values and count occurrences
3. Detect date gaps: expected continuous daily data within date range (accounting for weekends/holidays via business days)
4. Report tickers with gaps and gap date ranges

**Adjustment Consistency Checks:**
1. Verify `unadjusted_close != close` when dividends or splits occurred
2. Check for negative prices (invalid after adjustment)
3. Detect suspiciously large price jumps without corresponding adjustment info
4. Flag tickers with potential adjustment issues

**Point-in-Time Constituent Validation:**
1. Call `norgatedata.index_constituent_timeseries()` for specified index and date
2. Parse returned 0/1 time series to get list of constituent tickers at target date
3. Validate returned data is not empty (handle invalid index name or date)
4. Cache constituent data similar to price data for offline operation

**Delisting Detection:**
1. Use `*Current & Past` watchlists which include delisted securities
2. Check if ticker has price data ending before query end date (potential delisting)
3. Query Norgate for delisting information if available via API
4. Report delisting date and ticker in validation report

### Error Handling

**Custom Exceptions:**
[Source: architecture/components.md#custom-exceptions]
Use from `momo.utils.exceptions`:
- `ValidationError` - for validation failures
- `BridgeError` - for Windows Python bridge communication issues
- `NDUNotRunningError` - when Norgate Data Updater is not running
- `DataError` - general data layer errors

**Error Propagation:**
[Source: architecture/error-handling-strategy.md#general-approach]
- Validation functions should not fail fast - collect all issues and report comprehensively
- Use try/except around bridge calls with retry logic
- Log errors with structlog including full context
- Return ValidationReport with is_valid=False and detailed error messages

### Performance Considerations

- Validation on 1000+ tickers may be slow - add progress logging with structlog
- Consider caching validation results similar to price data
- Date gap detection should use pandas vectorized operations (no row-by-row iteration)
- Index constituent retrieval via bridge: ~7ms/symbol (acceptable for validation)

### Integration with Existing Code

**Story 1.3 Integration:**
- Validation functions will consume DataFrames produced by `momo.data.loader.load_universe()`
- Use same schema validation pattern from cache.py (`_validate_price_schema()`) as reference
- Can leverage cached Parquet files for validation without repeated bridge calls

**Story 1.2 Bridge Integration:**
- Add constituent retrieval function to bridge.py if not present
- Use existing retry/timeout logic from bridge
- Handle subprocess errors gracefully

## Testing

### Test Organization
[Source: architecture/test-strategy-and-standards.md#story-based-test-organization]

**Location:**
- Unit tests: `tests/stories/1.4/unit/`
- Integration tests: `tests/stories/1.4/integration/`

**Naming Convention:**
- File: `test_{story_id}_{level}_{seq}.py` (e.g., `test_1_4_unit_001.py`)
- Function: `test_1_4_unit_001()` (matches test ID)

### Required Test Markers
[Source: CLAUDE.md#story-based-test-organization]

**CRITICAL:** ALL test functions MUST have BOTH markers:
```python
@pytest.mark.p0  # Priority: p0 (critical), p1 (high), p2 (lower)
@pytest.mark.unit  # Level: unit or integration
def test_1_4_unit_001():
    ...
```

### Test Fixtures
[Source: architecture/test-strategy-and-standards.md#fixture-management]

**Global fixtures** (from `tests/conftest.py`):
- `project_root` - project root directory
- `data_dir` - data directory path

**Story-specific fixtures** (create in `tests/stories/1.4/conftest.py`):
- `sample_price_df_clean` - valid price DataFrame with no issues
- `sample_price_df_with_nans` - price DataFrame with NaN values for testing
- `sample_price_df_with_gaps` - price DataFrame with date gaps
- `mock_constituent_data` - mock index constituent time series
- `mock_validation_report` - sample ValidationReport for testing

**Test-specific fixtures** (inline in test file):
- Unique fixtures for specific edge cases

### Test Execution Commands
[Source: CLAUDE.md#development-commands]

```bash
# Run all Story 1.4 tests
uv run pytest tests/stories/1.4/ -v

# Run unit tests only
uv run pytest tests/stories/1.4/unit/ -v

# Run integration tests only
uv run pytest tests/stories/1.4/integration/ -v

# Run by priority
uv run pytest tests/stories/1.4/ -m p0 -v

# Run with coverage
uv run pytest tests/stories/1.4/ --cov=src/momo/data --cov-report=term-missing
```

### Type Checking
[Source: CLAUDE.md#type-checking--code-quality]

```bash
# Type check source
uv run mypy src/momo/data/validation.py

# Type check tests
uv run mypy tests/stories/1.4/
```

### Testing Framework
[Source: architecture/tech-stack.md#technology-stack-table]

- **Framework:** pytest 8.x
- **Coverage:** pytest-cov 5.x
- **Mocking:** pytest built-in fixtures and unittest.mock

### Test Coverage Goals
[Source: architecture/test-strategy-and-standards.md#testing-philosophy]

- **Target:** 90%+ for data layer validation module
- **Focus:** Critical validation logic (missing data, adjustment checks, constituent retrieval)

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-12-04 | 1.0 | Initial story draft created | Bob (Scrum Master) |

## Dev Agent Record

### Agent Model Used

claude-sonnet-4-5-20250929

### Debug Log References

_No debug issues encountered during commits 1-2_

### Completion Notes List

- [Commit 1] Successfully added ValidationError exception class as subclass of DataError
- [Commit 1] Created test file 1.4-UNIT-002 with proper markers (P0, unit) and test traceability
- [Commit 1] All quality gates passed: mypy, ruff check, ruff format, full test suite (76 passed)
- [Commit 2] Implemented ValidationReport dataclass with all 8 required fields (total_tickers, date_range, missing_data_counts, date_gaps, adjustment_issues, delisting_events, summary_message, is_valid)
- [Commit 2] Created validate_prices() skeleton function that accepts MultiIndex DataFrame and returns ValidationReport
- [Commit 2] Created story-level conftest.py with sample_price_df_clean fixture (5 tickers, 10 days, MultiIndex)
- [Commit 2] Created test files 1.4-UNIT-001, 003, 004 with proper markers and test traceability
- [Commit 2] All quality gates passed: mypy, ruff check, ruff format, full test suite (79 passed, 1 skipped)
- [Commit 3] Implemented _check_missing_values() helper function to detect NaN in OHLC columns (open, high, low, close)
- [Commit 3] Updated validate_prices() to call _check_missing_values() and populate missing_data_counts field
- [Commit 3] Added fixtures sample_price_df_with_nans_close and sample_price_df_with_nans_ohlc to conftest.py
- [Commit 3] Created test files 1.4-UNIT-005, 006, 007 with P0/unit markers and comprehensive test traceability
- [Commit 3] All quality gates passed: mypy, ruff check, ruff format, full test suite (82 passed, 1 skipped)

### File List

- src/momo/utils/exceptions.py - Added ValidationError exception class
- tests/stories/1.4/unit/test_1_4_unit_002.py - Test for ValidationError inheritance and import
- src/momo/data/validation.py - ValidationReport dataclass, validate_prices() with missing data detection, _check_missing_values() helper
- tests/stories/1.4/conftest.py - Story-level fixtures including sample_price_df_clean, sample_price_df_with_nans_close, sample_price_df_with_nans_ohlc
- tests/stories/1.4/unit/test_1_4_unit_001.py - Test for ValidationReport dataclass structure
- tests/stories/1.4/unit/test_1_4_unit_003.py - Test for validate_prices() MultiIndex acceptance
- tests/stories/1.4/unit/test_1_4_unit_004.py - Test for validate_prices() return type and clean data handling
- tests/stories/1.4/unit/test_1_4_unit_005.py - Test for validate_prices() with clean data reports no issues
- tests/stories/1.4/unit/test_1_4_unit_006.py - Test for _check_missing_values() detects NaN in close column
- tests/stories/1.4/unit/test_1_4_unit_007.py - Test for _check_missing_values() detects NaN across OHLC columns

## QA Results

_To be populated by QA Agent after implementation review_
