# Story 1.2: Integrate Norgate Data API via Windows Python Bridge

## Status

**Approved**

## Story

**As a** developer,
**I want** to connect to Norgate Data API via the Windows Python bridge,
**so that** I can retrieve historical price data for backtesting.

## Acceptance Criteria

1. `norgatedata` Python package is installed and importable
2. Windows Python bridge module (`src/momo/data/bridge.py`) implements subprocess-based NDU communication following the pattern from Story 1.0 exploration
3. Basic connection test successfully retrieves a sample ticker's price data via the bridge
4. Error handling provides clear messages if NDU is not running or accessible
5. Documentation in `docs/` explains the Windows Python bridge architecture and NDU prerequisites (Windows environment with NDU running and authenticated)
6. Unit test verifies bridge communication using mock subprocess responses

## Tasks / Subtasks

- [ ] Install norgatedata package (AC: 1)
  - [ ] Add norgatedata 1.0.74 to pyproject.toml dependencies
  - [ ] Run `uv sync` to install the package
  - [ ] Verify package is importable via Windows Python bridge

- [x] Implement Windows Python bridge module (AC: 2)
  - [x] Create `src/momo/data/bridge.py` with subprocess-based communication
  - [x] Implement `execute_norgate_code()` function to run Python code via `python.exe`
  - [x] Add JSON-based result serialization for data transfer between Windows and WSL Python
  - [x] Implement logging using structlog for all bridge operations

- [ ] Create helper functions for common Norgate operations (AC: 2)
  - [ ] Implement `fetch_price_data()` wrapper to retrieve OHLCV data for a symbol
  - [ ] Implement `check_ndu_status()` to verify NDU is running
  - [ ] Add proper type hints to all bridge functions
  - [ ] Document DataFrame schemas in docstrings

- [x] Implement error handling (AC: 4)
  - [x] Create custom exception classes in `src/momo/utils/exceptions.py` for bridge errors
  - [x] Handle NDU not running error (clear message to user)
  - [x] Handle Windows Python not found error
  - [x] Handle norgatedata package import errors
  - [x] Handle JSON serialization/deserialization errors
  - [x] Add timeout for subprocess calls (default 30 seconds)

- [ ] Create connection test (AC: 3)
  - [ ] Implement basic test script/function to fetch AAPL price data
  - [ ] Verify retrieved data has expected structure (Date index, OHLC columns)
  - [ ] Test with different adjustment types (CAPITAL, TOTALRETURN)
  - [ ] Log test results using structlog

- [ ] Write documentation (AC: 5)
  - [ ] Create `docs/architecture/windows-python-bridge.md` explaining bridge architecture
  - [ ] Document NDU prerequisites (Windows environment, authenticated subscription)
  - [ ] Document bridge usage patterns with code examples
  - [ ] Add troubleshooting section for common bridge errors
  - [ ] Document Windows Python path requirements

- [x] Write unit tests (AC: 6)
  - [x] Create test directory `tests/stories/1.2/unit/`
  - [ ] Create test directory `tests/stories/1.2/integration/`
  - [x] Write unit test for `execute_norgate_code()` with mock subprocess
  - [ ] Write unit test for `fetch_price_data()` with mock responses
  - [x] Write unit test for error handling paths
  - [ ] Write integration test for actual NDU connectivity (requires Windows environment)
  - [ ] Write integration test for price data retrieval via bridge

## Dev Notes

### Previous Story Insights

Story 1.0 (Norgate API Exploration Spike) and Story 1.1 (Initialize Project Structure) completed successfully. Key findings relevant to this story:

- **Windows Python Bridge Pattern Validated**: WSL development environment requires Windows Python (`python.exe`) to access Norgate Data Updater via subprocess
- **Data Storage Location**: All cached data should be saved to `/home/frank/momo/data/` (accessible from both WSL and Windows)
- **Full Subscription Confirmed**: Access to Russell 3000 Current & Past (12,225 symbols including 8,377 delisted)
- **Performance**: ~7ms per symbol, full Russell 3000 C&P fetch takes ~82 seconds
- **Adjustment Types**: Use TOTALRETURN for backtesting (includes dividends), CAPITAL for technical analysis
- **Project structure initialized**: All directories created, dependencies installed, tests passing

[Source: docs/research/norgate-api-exploration.md, docs/stories/1.1.story.md]

### Tech Stack (Required Versions)

| Technology | Version | Purpose |
|------------|---------|---------|
| Python | 3.13 | Primary development language |
| norgatedata | 1.0.74 | Market data API (Windows-only via bridge) |
| structlog | 24.x | Structured logging |
| tenacity | 9.x | Retry with backoff |

[Source: docs/architecture/tech-stack.md]

### Architecture Context

#### Windows Python Bridge Pattern

The bridge pattern is required because:
1. Development environment: WSL (Linux)
2. NDU (Norgate Data Updater): Runs on Windows host
3. norgatedata package: Requires direct communication with NDU process (Windows IPC)

**Solution**: Execute Python code via Windows Python (`python.exe`) from WSL Python, serialize results via JSON.

**Working approach** from Story 1.0:
```python
import subprocess
import json

def fetch_from_norgate(code: str) -> dict:
    """Execute Python code via Windows Python and return JSON result."""
    wrapper = f'''
import json
import norgatedata
result = {code}
print(json.dumps(result))
'''
    result = subprocess.run(
        ['python.exe', '-c', wrapper],
        capture_output=True,
        text=True
    )
    # Parse last line (skip norgatedata INFO messages)
    return json.loads(result.stdout.strip().split('\n')[-1])
```

[Source: docs/research/norgate-api-exploration.md#code-reference-windows-python-bridge-pattern]

#### Data Layer File Locations

From the project source tree, the data layer files are located at:
- `src/momo/data/bridge.py` - Windows Python bridge (to be created in this story)
- `src/momo/data/norgate.py` - Norgate API wrappers (future story)
- `src/momo/data/cache.py` - Parquet caching (future story)
- `src/momo/data/loader.py` - High-level data loading (future story)
- `src/momo/data/validation.py` - Data quality checks (future story)
- `src/momo/data/universe.py` - Point-in-time universe construction (future story)

[Source: docs/architecture/source-tree.md:36-43]

#### Data Models

Price data returned from Norgate via the bridge should have this schema:

| Attribute | Type | Description |
|-----------|------|-------------|
| `date` | `datetime64[ns]` | Trading date (DataFrame index) |
| `symbol` | `str` | Ticker symbol (e.g., "AAPL") |
| `open` | `float64` | Opening price (adjusted) |
| `high` | `float64` | High price (adjusted) |
| `low` | `float64` | Low price (adjusted) |
| `close` | `float64` | Closing price (adjusted) |
| `volume` | `int64` | Trading volume |
| `unadjusted_close` | `float64` | Raw close for reference |
| `dividend` | `float64` | Dividend amount (for TOTALRETURN adjustment) |

[Source: docs/architecture/data-models.md:6-20]

### Coding Standards

**Critical Rules** to follow:

1. **Always Use structlog** - Never `print()` or stdlib `logging`
2. **DataFrame Schema Documentation** - Document columns and dtypes in docstrings
3. **Explicit Date Handling** - Use `datetime.date`, not strings
4. **No Magic Numbers** - Name all constants or use config
5. **Validate at Layer Boundaries** - Data layer validates; inner layers trust input
6. **No Relative Imports Across Layers** - Use absolute imports from `momo`

**Naming Conventions**:
- DataFrame variables: Suffix `_df` (e.g., `prices_df`)
- Series variables: Suffix `_s` (e.g., `returns_s`)
- Date variables: Suffix `_date` (e.g., `start_date`)

[Source: docs/architecture/coding-standards.md:24-36]

### Exception Handling

Create custom exceptions in `src/momo/utils/exceptions.py` for bridge-specific errors:

```python
class BridgeError(Exception):
    """Base exception for Windows Python bridge errors."""
    pass

class NorgateBridgeError(BridgeError):
    """Norgate Data API errors via bridge."""
    pass

class NDUNotRunningError(NorgateBridgeError):
    """NDU (Norgate Data Updater) is not running."""
    pass

class WindowsPythonNotFoundError(BridgeError):
    """Windows Python executable not found."""
    pass
```

[Source: Inferred from docs/architecture/coding-standards.md:52]

### Testing Standards

**Test Organization**: Story-based (optimized for AI agent workflows)

- **Location Pattern**: `tests/stories/{story-id}/{level}/{test-id}.py`
- **File Naming**: `test_{story_id}_{level}_{seq}.py` (e.g., `test_1_2_unit_001.py`)
- **Test Function Naming**: `test_{story}_{level}_{seq}()` (e.g., `test_1_2_unit_001()`)
- **One Test Per File Principle**: Each test ID gets exactly one file for deterministic AI agent mapping

**Test File Structure Template**:

```python
"""
Test ID: {TEST-ID}
Story: {STORY-NUMBER} - {STORY-NAME}
Priority: P{0-3}
Test Level: {Unit|Integration|E2E}
Risk Coverage: {RISK-ID} ({Risk Title})

Description:
{Detailed description}

Acceptance Criteria: AC{N}
Test Design Reference: docs/qa/assessments/{story}-test-design-{date}.md:{line}
"""

import pytest

def test_{story}_{level}_{seq}():
    """
    {TEST-ID}: {Test scenario description}

    Justification: {Why this test exists}

    Expected: {Expected outcome}
    Failure mode: {What failure looks like}
    """
    # Arrange
    # Act
    # Assert
```

**Fixture Management**:
1. **Global fixtures** in `tests/conftest.py` - project structure paths (`project_root`, `src_dir`, `data_dir`)
2. **Story fixtures** in `tests/stories/{story}/conftest.py` - story-specific data
3. **Test fixtures** inline - unique setup for one test

**Test Types**:
- **Unit tests**: Mock subprocess calls, test error handling, no external dependencies
- **Integration tests**: Actual bridge communication (requires Windows environment with NDU)

[Source: docs/architecture/test-strategy-and-standards.md:1-630]

### Specific Testing Requirements for This Story

**Unit Tests** (tests/stories/1.2/unit/):
1. **test_1_2_unit_001.py**: Verify `execute_norgate_code()` calls subprocess with correct arguments (mock subprocess)
2. **test_1_2_unit_002.py**: Verify `execute_norgate_code()` parses JSON response correctly (mock subprocess)
3. **test_1_2_unit_003.py**: Verify `fetch_price_data()` constructs correct Norgate API call (mock execute_norgate_code)
4. **test_1_2_unit_004.py**: Verify error handling when NDU is not running (mock subprocess error)
5. **test_1_2_unit_005.py**: Verify error handling when Windows Python not found (mock FileNotFoundError)
6. **test_1_2_unit_006.py**: Verify timeout handling for long-running subprocess calls (mock timeout)

**Integration Tests** (tests/stories/1.2/integration/):
1. **test_1_2_int_001.py**: Verify `check_ndu_status()` returns True when NDU is running (requires Windows + NDU)
2. **test_1_2_int_002.py**: Verify `fetch_price_data()` retrieves actual AAPL data with correct schema (requires Windows + NDU)
3. **test_1_2_int_003.py**: Verify bridge handles norgatedata INFO messages correctly (requires Windows + NDU)

**Test Execution**:
```bash
# Run all Story 1.2 tests
pytest tests/stories/1.2/ -v

# Run only unit tests (no Windows/NDU required)
pytest tests/stories/1.2/unit/ -v

# Run only integration tests (requires Windows + NDU)
pytest tests/stories/1.2/integration/ -v
```

[Source: Inferred from docs/architecture/test-strategy-and-standards.md and Story 1.1 patterns]

### Bridge Implementation Details

**Key Implementation Points**:

1. **Subprocess Output Parsing**: norgatedata package prints INFO messages to stdout. Must parse only the last line for JSON result.

2. **Error Detection**: Check subprocess return code and stderr for errors before parsing JSON.

3. **Timeout**: Add timeout parameter (default 30 seconds) to prevent hanging on NDU communication failures.

4. **Retry Logic**: Use tenacity for retrying on transient errors (e.g., NDU temporarily busy).

5. **Logging**: Log all bridge operations (function calls, timing, errors) using structlog.

6. **Type Safety**: All functions must have complete type hints (pandas DataFrame, Optional types, etc.).

**Example Implementation Pattern**:

```python
import subprocess
import json
import structlog
from typing import Any, Optional
from tenacity import retry, stop_after_attempt, wait_fixed

from momo.utils.exceptions import (
    WindowsPythonNotFoundError,
    NDUNotRunningError,
    NorgateBridgeError
)

logger = structlog.get_logger()

@retry(stop=stop_after_attempt(3), wait=wait_fixed(1))
def execute_norgate_code(
    code: str,
    timeout: int = 30
) -> Any:
    """
    Execute Python code via Windows Python and return parsed result.

    Args:
        code: Python code to execute (must set 'result' variable)
        timeout: Subprocess timeout in seconds

    Returns:
        Parsed result from executed code

    Raises:
        WindowsPythonNotFoundError: python.exe not found
        NDUNotRunningError: NDU is not running
        NorgateBridgeError: Other bridge communication errors
    """
    logger.info("executing_norgate_code", code_length=len(code))

    # Construct wrapper code
    wrapper = f'''
import json
import norgatedata
result = {code}
print(json.dumps(result, default=str))
'''

    try:
        result = subprocess.run(
            ['python.exe', '-c', wrapper],
            capture_output=True,
            text=True,
            timeout=timeout
        )
    except FileNotFoundError:
        raise WindowsPythonNotFoundError(
            "Windows Python (python.exe) not found. Ensure it's in PATH."
        )
    except subprocess.TimeoutExpired:
        raise NorgateBridgeError(
            f"Bridge operation timed out after {timeout} seconds"
        )

    # Check for errors
    if result.returncode != 0:
        if "NDU is not running" in result.stderr:
            raise NDUNotRunningError(
                "Norgate Data Updater is not running. Please start NDU."
            )
        raise NorgateBridgeError(
            f"Bridge execution failed: {result.stderr}"
        )

    # Parse JSON from last line (skip norgatedata INFO messages)
    try:
        output_lines = result.stdout.strip().split('\n')
        json_line = output_lines[-1]
        parsed_result = json.loads(json_line)
        logger.info("norgate_code_executed", success=True)
        return parsed_result
    except (json.JSONDecodeError, IndexError) as e:
        raise NorgateBridgeError(
            f"Failed to parse bridge output: {e}\nOutput: {result.stdout}"
        )
```

[Source: Inferred from docs/research/norgate-api-exploration.md and architecture documents]

### Project Structure Notes

**Alignment**: Story requirements align with architecture documents. The bridge module fits into the data layer as defined in source-tree.md.

**Key Points**:
- The `bridge.py` module is the foundation for all Norgate data access
- Future stories will build on this bridge (norgate.py, cache.py, loader.py)
- Documentation should be created in `docs/architecture/windows-python-bridge.md`
- Test organization follows story-based pattern established in Story 1.1

[Source: docs/architecture/source-tree.md]

## Testing

**Test File Location**:
- Story-based location: `tests/stories/1.2/`
- Unit tests: `tests/stories/1.2/unit/`
- Integration tests: `tests/stories/1.2/integration/`

**Test Standards**:
- File naming: `test_1_2_unit_001.py`, `test_1_2_int_001.py`, etc.
- Test function naming: `test_1_2_unit_001()`, `test_1_2_int_001()`, etc.
- One test per file principle (deterministic AI agent mapping)
- Include docstring header with Test ID, Story, Priority, Test Level, Risk Coverage

**Testing Frameworks and Patterns**:
- Framework: pytest 8.x
- Mocking: unittest.mock for subprocess responses
- Integration tests require Windows environment with NDU running

**Test Execution**:
```bash
# Run all Story 1.2 tests
pytest tests/stories/1.2/ -v

# Run only unit tests (no Windows/NDU required)
pytest tests/stories/1.2/unit/ -v

# Run only integration tests (requires Windows + NDU)
pytest tests/stories/1.2/integration/ -v

# Run with coverage
pytest tests/stories/1.2/ --cov=src/momo/data --cov-report=term-missing
```

[Source: docs/architecture/test-strategy-and-standards.md]

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-12-04 | 1.0 | Story created from Epic 1 | BMad Master |

## Dev Agent Record

### Agent Model Used

claude-sonnet-4-5-20250929

### Debug Log References

None

### Completion Notes

- [Commit 1] Created foundational exception classes for Windows Python bridge error handling (BridgeError, NorgateBridgeError, NDUNotRunningError, WindowsPythonNotFoundError)
- [Commit 2] Implemented core Windows Python bridge with execute_norgate_code() function, comprehensive error handling, and structured logging using tenacity retry decorator for resilience

### File List

- src/momo/utils/exceptions.py - Custom exception classes for bridge error handling
- src/momo/data/bridge.py - Core Windows Python bridge with subprocess communication
- tests/stories/1.2/unit/__init__.py - Unit test package marker
- tests/stories/1.2/unit/test_1_2_unit_001.py - Test norgatedata import error handling
- tests/stories/1.2/unit/test_1_2_unit_002.py - Test subprocess call construction
- tests/stories/1.2/unit/test_1_2_unit_003.py - Test JSON parsing from stdout
- tests/stories/1.2/unit/test_1_2_unit_004.py - Test INFO message handling
- tests/stories/1.2/unit/test_1_2_unit_005.py - Test Windows Python not found error
- tests/stories/1.2/unit/test_1_2_unit_006.py - Test timeout handling
- tests/stories/1.2/unit/test_1_2_unit_007.py - Test logging validation
- ruff.toml - Added E501 ignore for test files (long docstring URLs)
