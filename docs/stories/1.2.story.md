# Story 1.2: Integrate Norgate Data API via Windows Python Bridge

## Status

**Done**

## Story

**As a** developer,
**I want** to connect to Norgate Data API via the Windows Python bridge,
**so that** I can retrieve historical price data for backtesting.

## Acceptance Criteria

1. `norgatedata` Python package is installed in Windows Python and accessible via bridge (not required in WSL Python)
2. Windows Python bridge module (`src/momo/data/bridge.py`) implements subprocess-based NDU communication following the pattern from Story 1.0 exploration
3. Basic connection test successfully retrieves a sample ticker's price data via the bridge
4. Error handling provides clear messages if NDU is not running or accessible
5. Documentation in `docs/` explains the Windows Python bridge architecture and NDU prerequisites (Windows environment with NDU running and authenticated)
6. Unit test verifies bridge communication using mock subprocess responses

## Tasks / Subtasks

- [x] Install norgatedata package (AC: 1)
  - [x] Add norgatedata 1.0.74 to pyproject.toml dependencies
  - [x] Run `uv sync` to install the package (may fail on WSL - this is expected)
  - [x] Verify Windows Python has norgatedata installed (required for bridge)
  - [x] Verify bridge can import and execute norgatedata code via `python.exe`

- [x] Implement Windows Python bridge module (AC: 2)
  - [x] Create `src/momo/data/bridge.py` with subprocess-based communication
  - [x] Implement `execute_norgate_code()` function to run Python code via `python.exe`
  - [x] Add JSON-based result serialization for data transfer between Windows and WSL Python
  - [x] Implement logging using structlog for all bridge operations

- [x] Create helper functions for common Norgate operations (AC: 2)
  - [x] Implement `fetch_price_data()` wrapper to retrieve OHLCV data for a symbol
  - [x] Implement `check_ndu_status()` to verify NDU is running
  - [x] Add proper type hints to all bridge functions
  - [x] Document DataFrame schemas in docstrings

- [x] Implement error handling (AC: 4)
  - [x] Create custom exception classes in `src/momo/utils/exceptions.py` for bridge errors
  - [x] Handle NDU not running error (clear message to user)
  - [x] Handle Windows Python not found error
  - [x] Handle norgatedata package import errors
  - [x] Handle JSON serialization/deserialization errors
  - [x] Add timeout for subprocess calls (default 30 seconds)

- [x] Create connection test (AC: 3)
  - [x] Implement basic test script/function to fetch AAPL price data
  - [x] Verify retrieved data has expected structure (Date index, OHLC columns)
  - [x] Test with different adjustment types (CAPITAL, TOTALRETURN)
  - [x] Log test results using structlog

- [x] Write documentation (AC: 5)
  - [x] Create `docs/architecture/windows-python-bridge.md` explaining bridge architecture
  - [x] Document NDU prerequisites (Windows environment, authenticated subscription)
  - [x] Document bridge usage patterns with code examples
  - [x] Add troubleshooting section for common bridge errors
  - [x] Document Windows Python path requirements

- [x] Write unit tests (AC: 6)
  - [x] Create test directory `tests/stories/1.2/unit/`
  - [x] Create test directory `tests/stories/1.2/integration/`
  - [x] Write unit test for `execute_norgate_code()` with mock subprocess
  - [x] Write unit test for `fetch_price_data()` with mock responses
  - [x] Write unit test for error handling paths
  - [x] Write integration test for actual NDU connectivity (requires Windows environment)
  - [x] Write integration test for price data retrieval via bridge
  - [x] Write integration test for basic bridge validation (test_1_2_int_003.py)
  - [x] Write integration test for AAPL data retrieval (test_1_2_int_005.py)
  - [x] Write integration test for schema validation (test_1_2_int_006.py)

## Dev Notes

### Previous Story Insights

Story 1.0 (Norgate API Exploration Spike) and Story 1.1 (Initialize Project Structure) completed successfully. Key findings relevant to this story:

- **Windows Python Bridge Pattern Validated**: WSL development environment requires Windows Python (`python.exe`) to access Norgate Data Updater via subprocess
- **Data Storage Location**: All cached data should be saved to `/home/frank/momo/data/` (accessible from both WSL and Windows)
- **Full Subscription Confirmed**: Access to Russell 3000 Current & Past (12,225 symbols including 8,377 delisted)
- **Performance**: ~7ms per symbol, full Russell 3000 C&P fetch takes ~82 seconds
- **Adjustment Types**: Use TOTALRETURN for backtesting (includes dividends), CAPITAL for technical analysis
- **Project structure initialized**: All directories created, dependencies installed, tests passing

[Source: docs/research/norgate-api-exploration.md, docs/stories/1.1.story.md]

### Tech Stack (Required Versions)

| Technology | Version | Purpose |
|------------|---------|---------|
| Python | 3.13 | Primary development language |
| norgatedata | 1.0.74 | Market data API (Windows-only via bridge) |
| structlog | 24.x | Structured logging |
| tenacity | 9.x | Retry with backoff |

[Source: docs/architecture/tech-stack.md]

### Architecture Context

#### Windows Python Bridge Pattern

The bridge pattern is required because:
1. Development environment: WSL (Linux)
2. NDU (Norgate Data Updater): Runs on Windows host
3. norgatedata package: Requires direct communication with NDU process (Windows IPC)

**Solution**: Execute Python code via Windows Python (`python.exe`) from WSL Python, serialize results via JSON.

**Working approach** from Story 1.0:
```python
import subprocess
import json

def fetch_from_norgate(code: str) -> dict:
    """Execute Python code via Windows Python and return JSON result."""
    wrapper = f'''
import json
import norgatedata
result = {code}
print(json.dumps(result))
'''
    result = subprocess.run(
        ['python.exe', '-c', wrapper],
        capture_output=True,
        text=True
    )
    # Parse last line (skip norgatedata INFO messages)
    return json.loads(result.stdout.strip().split('\n')[-1])
```

[Source: docs/research/norgate-api-exploration.md#code-reference-windows-python-bridge-pattern]

#### Data Layer File Locations

From the project source tree, the data layer files are located at:
- `src/momo/data/bridge.py` - Windows Python bridge (to be created in this story)
- `src/momo/data/norgate.py` - Norgate API wrappers (future story)
- `src/momo/data/cache.py` - Parquet caching (future story)
- `src/momo/data/loader.py` - High-level data loading (future story)
- `src/momo/data/validation.py` - Data quality checks (future story)
- `src/momo/data/universe.py` - Point-in-time universe construction (future story)

[Source: docs/architecture/source-tree.md:36-43]

#### Data Models

Price data returned from Norgate via the bridge should have this schema:

| Attribute | Type | Description |
|-----------|------|-------------|
| `date` | `datetime64[ns]` | Trading date (DataFrame index) |
| `symbol` | `str` | Ticker symbol (e.g., "AAPL") |
| `open` | `float64` | Opening price (adjusted) |
| `high` | `float64` | High price (adjusted) |
| `low` | `float64` | Low price (adjusted) |
| `close` | `float64` | Closing price (adjusted) |
| `volume` | `int64` | Trading volume |
| `unadjusted_close` | `float64` | Raw close for reference |
| `dividend` | `float64` | Dividend amount (for TOTALRETURN adjustment) |

[Source: docs/architecture/data-models.md:6-20]

### Coding Standards

**Critical Rules** to follow:

1. **Always Use structlog** - Never `print()` or stdlib `logging`
2. **DataFrame Schema Documentation** - Document columns and dtypes in docstrings
3. **Explicit Date Handling** - Use `datetime.date`, not strings
4. **No Magic Numbers** - Name all constants or use config
5. **Validate at Layer Boundaries** - Data layer validates; inner layers trust input
6. **No Relative Imports Across Layers** - Use absolute imports from `momo`

**Naming Conventions**:
- DataFrame variables: Suffix `_df` (e.g., `prices_df`)
- Series variables: Suffix `_s` (e.g., `returns_s`)
- Date variables: Suffix `_date` (e.g., `start_date`)

[Source: docs/architecture/coding-standards.md:24-36]

### Exception Handling

Create custom exceptions in `src/momo/utils/exceptions.py` for bridge-specific errors:

```python
class BridgeError(Exception):
    """Base exception for Windows Python bridge errors."""
    pass

class NorgateBridgeError(BridgeError):
    """Norgate Data API errors via bridge."""
    pass

class NDUNotRunningError(NorgateBridgeError):
    """NDU (Norgate Data Updater) is not running."""
    pass

class WindowsPythonNotFoundError(BridgeError):
    """Windows Python executable not found."""
    pass
```

[Source: Inferred from docs/architecture/coding-standards.md:52]

### Testing Standards

**Test Organization**: Story-based (optimized for AI agent workflows)

- **Location Pattern**: `tests/stories/{story-id}/{level}/{test-id}.py`
- **File Naming**: `test_{story_id}_{level}_{seq}.py` (e.g., `test_1_2_unit_001.py`)
- **Test Function Naming**: `test_{story}_{level}_{seq}()` (e.g., `test_1_2_unit_001()`)
- **One Test Per File Principle**: Each test ID gets exactly one file for deterministic AI agent mapping

**Test File Structure Template**:

```python
"""
Test ID: {TEST-ID}
Story: {STORY-NUMBER} - {STORY-NAME}
Priority: P{0-3}
Test Level: {Unit|Integration|E2E}
Risk Coverage: {RISK-ID} ({Risk Title})

Description:
{Detailed description}

Acceptance Criteria: AC{N}
Test Design Reference: docs/qa/assessments/{story}-test-design-{date}.md:{line}
"""

import pytest

def test_{story}_{level}_{seq}():
    """
    {TEST-ID}: {Test scenario description}

    Justification: {Why this test exists}

    Expected: {Expected outcome}
    Failure mode: {What failure looks like}
    """
    # Arrange
    # Act
    # Assert
```

**Fixture Management**:
1. **Global fixtures** in `tests/conftest.py` - project structure paths (`project_root`, `src_dir`, `data_dir`)
2. **Story fixtures** in `tests/stories/{story}/conftest.py` - story-specific data
3. **Test fixtures** inline - unique setup for one test

**Test Types**:
- **Unit tests**: Mock subprocess calls, test error handling, no external dependencies
- **Integration tests**: Actual bridge communication (requires Windows environment with NDU)

[Source: docs/architecture/test-strategy-and-standards.md:1-630]

### Specific Testing Requirements for This Story

**Unit Tests** (tests/stories/1.2/unit/):
1. **test_1_2_unit_001.py**: Verify `execute_norgate_code()` calls subprocess with correct arguments (mock subprocess)
2. **test_1_2_unit_002.py**: Verify `execute_norgate_code()` parses JSON response correctly (mock subprocess)
3. **test_1_2_unit_003.py**: Verify `fetch_price_data()` constructs correct Norgate API call (mock execute_norgate_code)
4. **test_1_2_unit_004.py**: Verify error handling when NDU is not running (mock subprocess error)
5. **test_1_2_unit_005.py**: Verify error handling when Windows Python not found (mock FileNotFoundError)
6. **test_1_2_unit_006.py**: Verify timeout handling for long-running subprocess calls (mock timeout)

**Integration Tests** (tests/stories/1.2/integration/):
1. **test_1_2_int_001.py**: Verify `check_ndu_status()` returns True when NDU is running (requires Windows + NDU)
2. **test_1_2_int_002.py**: Verify `fetch_price_data()` retrieves actual AAPL data with correct schema (requires Windows + NDU)
3. **test_1_2_int_003.py**: Verify bridge handles norgatedata INFO messages correctly (requires Windows + NDU)

**Test Execution**:
```bash
# Run all Story 1.2 tests
pytest tests/stories/1.2/ -v

# Run only unit tests (no Windows/NDU required)
pytest tests/stories/1.2/unit/ -v

# Run only integration tests (requires Windows + NDU)
pytest tests/stories/1.2/integration/ -v
```

[Source: Inferred from docs/architecture/test-strategy-and-standards.md and Story 1.1 patterns]

### Bridge Implementation Details

**Key Implementation Points**:

1. **Subprocess Output Parsing**: norgatedata package prints INFO messages to stdout. Must parse only the last line for JSON result.

2. **Error Detection**: Check subprocess return code and stderr for errors before parsing JSON.

3. **Timeout**: Add timeout parameter (default 30 seconds) to prevent hanging on NDU communication failures.

4. **Retry Logic**: Use tenacity for retrying on transient errors (e.g., NDU temporarily busy).

5. **Logging**: Log all bridge operations (function calls, timing, errors) using structlog.

6. **Type Safety**: All functions must have complete type hints (pandas DataFrame, Optional types, etc.).

**Example Implementation Pattern**:

```python
import subprocess
import json
import structlog
from typing import Any, Optional
from tenacity import retry, stop_after_attempt, wait_fixed

from momo.utils.exceptions import (
    WindowsPythonNotFoundError,
    NDUNotRunningError,
    NorgateBridgeError
)

logger = structlog.get_logger()

@retry(stop=stop_after_attempt(3), wait=wait_fixed(1))
def execute_norgate_code(
    code: str,
    timeout: int = 30
) -> Any:
    """
    Execute Python code via Windows Python and return parsed result.

    Args:
        code: Python code to execute (must set 'result' variable)
        timeout: Subprocess timeout in seconds

    Returns:
        Parsed result from executed code

    Raises:
        WindowsPythonNotFoundError: python.exe not found
        NDUNotRunningError: NDU is not running
        NorgateBridgeError: Other bridge communication errors
    """
    logger.info("executing_norgate_code", code_length=len(code))

    # Construct wrapper code
    wrapper = f'''
import json
import norgatedata
result = {code}
print(json.dumps(result, default=str))
'''

    try:
        result = subprocess.run(
            ['python.exe', '-c', wrapper],
            capture_output=True,
            text=True,
            timeout=timeout
        )
    except FileNotFoundError:
        raise WindowsPythonNotFoundError(
            "Windows Python (python.exe) not found. Ensure it's in PATH."
        )
    except subprocess.TimeoutExpired:
        raise NorgateBridgeError(
            f"Bridge operation timed out after {timeout} seconds"
        )

    # Check for errors
    if result.returncode != 0:
        if "NDU is not running" in result.stderr:
            raise NDUNotRunningError(
                "Norgate Data Updater is not running. Please start NDU."
            )
        raise NorgateBridgeError(
            f"Bridge execution failed: {result.stderr}"
        )

    # Parse JSON from last line (skip norgatedata INFO messages)
    try:
        output_lines = result.stdout.strip().split('\n')
        json_line = output_lines[-1]
        parsed_result = json.loads(json_line)
        logger.info("norgate_code_executed", success=True)
        return parsed_result
    except (json.JSONDecodeError, IndexError) as e:
        raise NorgateBridgeError(
            f"Failed to parse bridge output: {e}\nOutput: {result.stdout}"
        )
```

[Source: Inferred from docs/research/norgate-api-exploration.md and architecture documents]

### Project Structure Notes

**Alignment**: Story requirements align with architecture documents. The bridge module fits into the data layer as defined in source-tree.md.

**Key Points**:
- The `bridge.py` module is the foundation for all Norgate data access
- Future stories will build on this bridge (norgate.py, cache.py, loader.py)
- Documentation should be created in `docs/architecture/windows-python-bridge.md`
- Test organization follows story-based pattern established in Story 1.1

[Source: docs/architecture/source-tree.md]

## Testing

**Test File Location**:
- Story-based location: `tests/stories/1.2/`
- Unit tests: `tests/stories/1.2/unit/`
- Integration tests: `tests/stories/1.2/integration/`

**Test Standards**:
- File naming: `test_1_2_unit_001.py`, `test_1_2_int_001.py`, etc.
- Test function naming: `test_1_2_unit_001()`, `test_1_2_int_001()`, etc.
- One test per file principle (deterministic AI agent mapping)
- Include docstring header with Test ID, Story, Priority, Test Level, Risk Coverage

**Testing Frameworks and Patterns**:
- Framework: pytest 8.x
- Mocking: unittest.mock for subprocess responses
- Integration tests require Windows environment with NDU running

**Test Execution**:
```bash
# Run all Story 1.2 tests
pytest tests/stories/1.2/ -v

# Run only unit tests (no Windows/NDU required)
pytest tests/stories/1.2/unit/ -v

# Run only integration tests (requires Windows + NDU)
pytest tests/stories/1.2/integration/ -v

# Run with coverage
pytest tests/stories/1.2/ --cov=src/momo/data --cov-report=term-missing
```

[Source: docs/architecture/test-strategy-and-standards.md]

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-12-04 | 1.0 | Story created from Epic 1 | BMad Master |

## Dev Agent Record

### Agent Model Used

claude-sonnet-4-5-20250929

### Debug Log References

- [Commit 3] Added pandas to mypy ignore configuration to suppress untyped import warnings from pandas library

### Completion Notes

- [Commit 1] Created foundational exception classes for Windows Python bridge error handling (BridgeError, NorgateBridgeError, NDUNotRunningError, WindowsPythonNotFoundError)
- [Commit 2] Implemented core Windows Python bridge with execute_norgate_code() function, comprehensive error handling, and structured logging using tenacity retry decorator for resilience
- [Commit 3] Added helper functions fetch_price_data() and check_ndu_status() with complete DataFrame schema documentation, type hints, and comprehensive unit tests (1.2-UNIT-008, 1.2-UNIT-009, 1.2-UNIT-011)
- [Commit 4] Added integration test directory and implemented integration tests for NDU connectivity (1.2-INT-001, 1.2-INT-008) and unit test for NDU error handling (1.2-UNIT-010), validated Windows Python bridge works in real environment
- [Commit 5] Implemented integration tests for price data retrieval (1.2-INT-003, 1.2-INT-005, 1.2-INT-006) validating basic bridge communication, AAPL data fetching, and DataFrame schema compliance with documented data models
- [Commit 6] Added advanced integration tests (1.2-INT-002, 1.2-INT-004, 1.2-INT-007) for norgatedata version validation, concurrent request handling without deadlocks, and adjustment type variations (CAPITAL vs TOTALRETURN)
- [Commit 7] Created comprehensive architecture documentation (docs/architecture/windows-python-bridge.md) covering subprocess communication pattern, prerequisites, usage examples for all public functions, error handling, troubleshooting guide, performance characteristics, and known limitations

### File List

- src/momo/utils/exceptions.py - Custom exception classes for bridge error handling
- src/momo/data/bridge.py - Core Windows Python bridge with subprocess communication, fetch_price_data(), check_ndu_status()
- tests/stories/1.2/unit/__init__.py - Unit test package marker
- tests/stories/1.2/unit/test_1_2_unit_001.py - Test norgatedata import error handling
- tests/stories/1.2/unit/test_1_2_unit_002.py - Test subprocess call construction
- tests/stories/1.2/unit/test_1_2_unit_003.py - Test JSON parsing from stdout
- tests/stories/1.2/unit/test_1_2_unit_004.py - Test INFO message handling
- tests/stories/1.2/unit/test_1_2_unit_005.py - Test Windows Python not found error
- tests/stories/1.2/unit/test_1_2_unit_006.py - Test timeout handling
- tests/stories/1.2/unit/test_1_2_unit_007.py - Test logging validation
- tests/stories/1.2/unit/test_1_2_unit_008.py - Test fetch_price_data() API call construction
- tests/stories/1.2/unit/test_1_2_unit_009.py - Test fetch_price_data() DataFrame schema parsing
- tests/stories/1.2/unit/test_1_2_unit_010.py - Test execute_norgate_code() raises NDUNotRunningError with clear message
- tests/stories/1.2/unit/test_1_2_unit_011.py - Test check_ndu_status() NDU availability detection
- tests/stories/1.2/integration/__init__.py - Integration test package marker
- tests/stories/1.2/integration/test_1_2_int_001.py - Integration test for norgatedata package importable via bridge
- tests/stories/1.2/integration/test_1_2_int_002.py - Integration test for norgatedata version validation (1.0.74)
- tests/stories/1.2/integration/test_1_2_int_003.py - Integration test for basic bridge validation without NDU
- tests/stories/1.2/integration/test_1_2_int_004.py - Integration test for concurrent request handling without deadlocks
- tests/stories/1.2/integration/test_1_2_int_005.py - Integration test for AAPL data retrieval via bridge
- tests/stories/1.2/integration/test_1_2_int_006.py - Integration test for DataFrame schema validation
- tests/stories/1.2/integration/test_1_2_int_007.py - Integration test for adjustment type variations (CAPITAL vs TOTALRETURN)
- tests/stories/1.2/integration/test_1_2_int_008.py - Integration test for bridge error messages when NDU stopped
- tests/stories/1.1/integration/test_1_1_int_005.py - Fixed unused type:ignore comment for pandas import
- mypy.ini - Added pandas to ignore_missing_imports configuration
- ruff.toml - Added E501 ignore for test files (long docstring URLs)
- docs/architecture/windows-python-bridge.md - Comprehensive Windows Python bridge architecture documentation with usage examples, troubleshooting guide, and performance characteristics

## QA Results

### Review Date: 2025-12-04

### Reviewed By: Quinn (Test Architect)

### Code Quality Assessment

**Overall Assessment:** EXCELLENT - This is exemplary infrastructure code demonstrating best practices in error handling, testing, and documentation.

**Strengths:**
1. **Robust Error Handling:** Comprehensive exception hierarchy with clear, actionable error messages
2. **Test Coverage:** 95% code coverage (90/95 statements) with excellent unit/integration test balance
3. **Documentation Excellence:** Outstanding architecture documentation with troubleshooting guide and real-world examples
4. **Type Safety:** Full type annotations with strict mypy compliance (zero issues)
5. **Architecture Alignment:** Perfect adherence to layered pipeline architecture (Data layer)
6. **Pure Function Compliance:** N/A for this story (bridge is I/O layer, pure function rules apply to Signal/Portfolio layers)

**Key Implementation Highlights:**
- Intelligent JSON parsing strategy (last line only) handles norgatedata INFO messages correctly
- Retry logic using tenacity provides resilience for transient failures
- Structured logging with structlog enables observability for debugging subprocess issues
- DataFrame schema documentation in docstrings matches data models specification exactly
- Timeout configuration allows per-operation tuning (default 30s, check_ndu_status 10s)

### Refactoring Performed

**File:** src/momo/data/bridge.py (bridge.py:109-112)

**Change:** Enhanced generic error handling to include stdout in error messages

**Before:**
```python
logger.error("bridge_execution_failed", stderr=result.stderr)
raise NorgateBridgeError(f"Bridge execution failed: {result.stderr}")
```

**After:**
```python
logger.error("bridge_execution_failed", stderr=result.stderr, stdout=result.stdout)
raise NorgateBridgeError(
    f"Bridge execution failed:\nStderr: {result.stderr}\nStdout: {result.stdout}"
)
```

**Why:** Generic subprocess errors may have useful diagnostic information in stdout that was previously not captured. Including both stderr and stdout improves debugging capability for edge cases not covered by specific error handlers.

**How:** This change improves observability without altering behavior. When specific error patterns (NDU not running, module not found) don't match, developers now see full subprocess output. All tests continue to pass (26 passed, 1 skipped).

### Compliance Check

- Coding Standards: ✓ **PASS** - All naming conventions followed (`_df` suffix, structlog usage, type hints)
- Project Structure: ✓ **PASS** - Bridge module correctly placed in data layer (src/momo/data/)
- Testing Strategy: ✓ **PASS** - Story-based test organization, one test per file, appropriate test levels
- All ACs Met: ✓ **PASS** - All 6 acceptance criteria validated with comprehensive test coverage

**Detailed Compliance:**
1. **AC1 (Package installed):** Validated by 1.2-INT-001, 1.2-INT-002, 1.2-UNIT-001
2. **AC2 (Bridge implementation):** Validated by 1.2-UNIT-002 through 1.2-UNIT-007, 1.2-INT-003, 1.2-INT-004
3. **AC3 (Connection test):** Validated by 1.2-INT-005, 1.2-INT-006, 1.2-INT-007, 1.2-UNIT-008, 1.2-UNIT-009
4. **AC4 (Error handling):** Validated by 1.2-UNIT-010, 1.2-UNIT-011, 1.2-INT-008
5. **AC5 (Documentation):** Manual review - docs/architecture/windows-python-bridge.md is exceptional
6. **AC6 (Unit tests):** Meta AC - all unit tests use mock subprocess responses correctly

### Improvements Checklist

**Completed During Review:**
- [x] Enhanced generic error messages to include stdout (bridge.py:109-112)
- [x] Verified all tests pass after refactoring (26 passed, 1 skipped)
- [x] Confirmed 95% code coverage maintained

**No Additional Actions Required:**
- [x] Error handling is comprehensive (all identified risks mitigated)
- [x] Logging is appropriate (structlog with rich context)
- [x] Documentation is thorough (987 lines of detailed architecture docs)
- [x] Test coverage is excellent (16 test scenarios, all P0 tests implemented)
- [x] Type safety is enforced (mypy strict mode passes)
- [x] Performance characteristics documented (7ms per symbol from Story 1.0 validated)

### Requirements Traceability

**Acceptance Criteria to Test Mapping:**

| AC | Description | Test IDs | Coverage |
|----|-------------|----------|----------|
| AC1 | Package installed and importable | 1.2-INT-001, 1.2-INT-002, 1.2-UNIT-001 | ✓ Complete |
| AC2 | Bridge implements subprocess communication | 1.2-UNIT-002, 1.2-UNIT-003, 1.2-UNIT-004, 1.2-UNIT-005, 1.2-UNIT-006, 1.2-UNIT-007, 1.2-INT-003, 1.2-INT-004 | ✓ Complete |
| AC3 | Connection test retrieves data | 1.2-INT-005, 1.2-INT-006, 1.2-INT-007, 1.2-UNIT-008, 1.2-UNIT-009 | ✓ Complete |
| AC4 | Error handling with clear messages | 1.2-UNIT-010, 1.2-UNIT-011, 1.2-INT-008 | ✓ Complete |
| AC5 | Documentation explains architecture | Manual review | ✓ Complete |
| AC6 | Unit tests verify bridge | All 1.2-UNIT-* tests | ✓ Complete |

**Risk Coverage Validation:**

All 8 risks from risk profile (1.2-risk-20251204.md) have appropriate test coverage:

| Risk ID | Severity | Test Coverage | Status |
|---------|----------|---------------|--------|
| TECH-001 | Critical (9) | 1.2-UNIT-002, 1.2-UNIT-003, 1.2-INT-001, 1.2-INT-003, 1.2-INT-005 | ✓ Mitigated |
| OPS-001 | High (6) | 1.2-UNIT-001, 1.2-UNIT-010, 1.2-UNIT-011, 1.2-INT-008 | ✓ Mitigated |
| DATA-001 | High (6) | 1.2-UNIT-003, 1.2-UNIT-008, 1.2-UNIT-009, 1.2-INT-006 | ✓ Mitigated |
| PERF-001 | Medium (4) | 1.2-UNIT-006, 1.2-INT-004 | ✓ Mitigated |
| TECH-002 | Medium (4) | 1.2-UNIT-005, 1.2-INT-002 | ✓ Mitigated |
| DATA-002 | Medium (4) | 1.2-UNIT-004 | ✓ Mitigated |
| SEC-001 | Low (3) | Code review confirms internal API only | ✓ Acceptable |
| OPS-002 | Low (2) | 1.2-UNIT-007, 1.2-INT-008 | ✓ Mitigated |

### Security Review

**Assessment:** PASS - No security concerns identified

**Analysis:**
1. **Command Injection Risk (SEC-001):** MITIGATED
   - `execute_norgate_code()` is internal API, not exposed to external input
   - All callers (`fetch_price_data`, `check_ndu_status`) construct code programmatically
   - No user-provided strings pass through to subprocess
   - Recommendation: Keep function internal (not in public API)

2. **Subprocess Security:** PASS
   - Uses `subprocess.run()` with explicit command array (not shell=True)
   - No shell metacharacter injection possible
   - Timeout prevents DoS via hanging subprocess

3. **Data Serialization:** PASS
   - JSON serialization is safe (no pickle/eval usage)
   - DataFrame deserialization uses pandas built-in methods

### Performance Considerations

**Assessment:** PASS - Performance characteristics documented and acceptable

**Benchmark Validation:**
- Single symbol fetch: ~57ms (50ms subprocess overhead + 7ms NDU lookup) - matches Story 1.0 findings
- Concurrent requests: Tested up to 10 concurrent (1.2-INT-004) without deadlocks
- Timeout defaults: Appropriate (30s general, 10s status check)
- Retry strategy: 3 attempts with 1s wait - reasonable for transient failures

**Optimization Opportunities (Future Stories):**
- Batch symbol fetching (reduce subprocess overhead from 50ms to 7ms per symbol)
- Parquet caching (eliminate repeated bridge calls)
- Connection pooling (reuse subprocess/NDU connections)

**No Performance Blockers:** Current implementation is suitable for Story 1.2 scope.

### Files Modified During Review

**During QA Review:**
- src/momo/data/bridge.py (lines 109-112) - Enhanced error message to include stdout

**Note to Dev:** Please add this file change to the "File List" section in Dev Agent Record if creating a new commit.

### Non-Functional Requirements Assessment

**Security:** ✓ PASS - Command injection mitigated, no external input exposure
**Performance:** ✓ PASS - 95% coverage, <12s test execution, ~57ms per symbol fetch
**Reliability:** ✓ PASS - Comprehensive error handling, retry logic, clear error messages
**Maintainability:** ✓ PASS - Excellent documentation, type safety, test coverage
**Testability:** ✓ PASS - High unit test coverage with mocks, integration tests validate real environment
**Observability:** ✓ PASS - Structured logging with rich context for debugging

### Gate Status

Gate: **PASS** → docs/qa/gates/1.2-integrate-norgate-data-api.yml

Risk profile: docs/qa/assessments/1.2-risk-20251204.md
Test design: docs/qa/assessments/1.2-test-design-20251204.md
NFR assessment: All NFRs validated as PASS (see above)

### Recommended Status

✓ **Ready for Done**

**Justification:**
1. All 6 acceptance criteria fully implemented and validated
2. 95% code coverage (90/95 statements) exceeds 85% target
3. All P0 tests passing (11/11 P0 tests implemented)
4. Zero mypy errors, zero ruff violations
5. Comprehensive documentation (987 lines)
6. All critical and high risks mitigated with test coverage
7. Minor refactoring completed during review improves observability
8. No blocking issues identified

**Quality Score:** 98/100 (100 - 0 FAILs - 0 CONCERNS = 100, adjusted to 98 for one skipped integration test requiring manual NDU stop)

This story represents exemplary engineering quality and is ready for production use.
