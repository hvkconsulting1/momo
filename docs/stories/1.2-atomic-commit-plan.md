# Atomic Commit Plan: Story 1.2

**Total Commits:** 7
**Test Coverage:** 16/16 tests (11 P0, 3 P1, 2 P2)
**AC Coverage:** 6/6 acceptance criteria

---

## Commit 1: feat(data): add bridge exception classes for error handling

**Tests:** N/A (foundation for other tests)
**ACs:** 4
**Priority:** P0

**Setup:**
- Create `src/momo/utils/exceptions.py`
- Define `BridgeError` base exception class
- Define `NorgateBridgeError(BridgeError)` for Norgate-specific errors
- Define `NDUNotRunningError(NorgateBridgeError)` for NDU availability errors
- Define `WindowsPythonNotFoundError(BridgeError)` for environment errors
- Add docstrings explaining when each exception should be raised

**Verification:**
- File `src/momo/utils/exceptions.py` exists
- All exception classes importable: `from momo.utils.exceptions import BridgeError, NorgateBridgeError, NDUNotRunningError, WindowsPythonNotFoundError`
- No syntax errors

---

## Commit 2: feat(data): implement core Windows Python bridge with subprocess communication

**Tests:** 1.2-UNIT-001, 1.2-UNIT-002, 1.2-UNIT-003, 1.2-UNIT-004, 1.2-UNIT-005, 1.2-UNIT-006, 1.2-UNIT-007
**ACs:** 1, 2, 4
**Priority:** P0

**Setup:**
- Create `src/momo/data/bridge.py`
- Implement `execute_norgate_code(code: str, timeout: int = 30) -> Any` function:
  - Construct Python wrapper code with JSON serialization
  - Execute via `subprocess.run(['python.exe', '-c', wrapper], ...)` with timeout
  - Handle `FileNotFoundError` → raise `WindowsPythonNotFoundError`
  - Handle `subprocess.TimeoutExpired` → raise `NorgateBridgeError`
  - Check return code and stderr for errors
  - Detect "NDU is not running" in stderr → raise `NDUNotRunningError`
  - Parse only last line of stdout for JSON (skip INFO messages)
  - Use `json.loads()` to deserialize result
  - Add structlog logging for all operations (executing, success, errors)
  - Use tenacity `@retry` decorator (3 attempts, 1-second wait)
- Add complete type hints
- Create test directory `tests/stories/1.2/unit/`
- Create unit tests:
  - `tests/stories/1.2/unit/test_1_2_unit_001.py`: norgatedata import error handling
  - `tests/stories/1.2/unit/test_1_2_unit_002.py`: subprocess call construction
  - `tests/stories/1.2/unit/test_1_2_unit_003.py`: JSON parsing from stdout
  - `tests/stories/1.2/unit/test_1_2_unit_004.py`: INFO message handling
  - `tests/stories/1.2/unit/test_1_2_unit_005.py`: Windows Python not found error
  - `tests/stories/1.2/unit/test_1_2_unit_006.py`: timeout handling
  - `tests/stories/1.2/unit/test_1_2_unit_007.py`: logging validation
- All unit tests should use `unittest.mock` to mock `subprocess.run`

**Verification:**
- `src/momo/data/bridge.py` exists with `execute_norgate_code()` function
- All 7 unit tests pass: `pytest tests/stories/1.2/unit/ -v`
- Type checking passes: `uv run mypy src/momo/data/bridge.py`
- Linting passes: `uv run ruff check src/momo/data/bridge.py`

---

## Commit 3: feat(data): add helper functions for Norgate data operations

**Tests:** 1.2-UNIT-008, 1.2-UNIT-009, 1.2-UNIT-011
**ACs:** 2, 3, 4
**Priority:** P0

**Setup:**
- In `src/momo/data/bridge.py`, add:
  - `fetch_price_data(symbol: str, start_date: date | None = None, end_date: date | None = None, adjustment: str = "TOTALRETURN", timeout: int = 30) -> pd.DataFrame`:
    - Construct norgatedata API call code string
    - Call `execute_norgate_code()` with constructed code
    - Parse JSON response into pandas DataFrame
    - Validate schema (columns: date, symbol, open, high, low, close, volume)
    - Set date column as index
    - Ensure correct dtypes (float64 for prices, int64 for volume, datetime64[ns] for date)
    - Add docstring documenting DataFrame schema
  - `check_ndu_status(timeout: int = 10) -> bool`:
    - Try calling simple norgatedata function via `execute_norgate_code()`
    - Return True if successful
    - Catch `NDUNotRunningError` and return False
    - Add docstring
- Add complete type hints for all functions
- Create unit tests:
  - `tests/stories/1.2/unit/test_1_2_unit_008.py`: Verify `fetch_price_data()` constructs correct Norgate API call
  - `tests/stories/1.2/unit/test_1_2_unit_009.py`: Verify DataFrame schema parsing
  - `tests/stories/1.2/unit/test_1_2_unit_011.py`: Verify `check_ndu_status()` detects NDU status
- All unit tests should mock `execute_norgate_code()`

**Verification:**
- Both helper functions exist in `src/momo/data/bridge.py`
- Unit tests 1.2-UNIT-008, 1.2-UNIT-009, 1.2-UNIT-011 pass
- Type checking passes: `uv run mypy src/momo/data/bridge.py`
- Functions have complete docstrings with DataFrame schema documentation

---

## Commit 4: test(data): add integration tests for NDU connectivity and error handling

**Tests:** 1.2-UNIT-010, 1.2-INT-001, 1.2-INT-008
**ACs:** 1, 4
**Priority:** P0

**Setup:**
- Create test directory `tests/stories/1.2/integration/`
- Create unit test:
  - `tests/stories/1.2/unit/test_1_2_unit_010.py`: Verify `execute_norgate_code()` raises `NDUNotRunningError` with clear message (mock subprocess)
- Create integration tests:
  - `tests/stories/1.2/integration/test_1_2_int_001.py`: Verify norgatedata package importable via bridge (requires Windows Python + norgatedata)
  - `tests/stories/1.2/integration/test_1_2_int_008.py`: Verify error messages are actionable when NDU stopped (requires Windows environment)
- Add test docstrings with Test ID, Story, Priority, Risk Coverage as per test standards

**Verification:**
- Unit test 1.2-UNIT-010 passes with mocked subprocess
- Integration tests require Windows environment:
  - `pytest tests/stories/1.2/integration/test_1_2_int_001.py -v` (requires Windows Python with norgatedata)
  - `pytest tests/stories/1.2/integration/test_1_2_int_008.py -v` (requires ability to start/stop NDU)
- All tests follow story-based organization and naming conventions

---

## Commit 5: test(data): add integration tests for price data retrieval

**Tests:** 1.2-INT-003, 1.2-INT-005, 1.2-INT-006
**ACs:** 2, 3
**Priority:** P0

**Setup:**
- Create integration tests:
  - `tests/stories/1.2/integration/test_1_2_int_003.py`: Verify bridge executes simple Python code via Windows (no NDU required)
  - `tests/stories/1.2/integration/test_1_2_int_005.py`: Verify `fetch_price_data()` retrieves AAPL data (requires NDU)
  - `tests/stories/1.2/integration/test_1_2_int_006.py`: Verify retrieved data has expected schema (requires NDU)
- Each test should include:
  - Complete docstring header with Test ID, Story, Priority, Test Level, Risk Coverage
  - Clear test steps (Arrange, Act, Assert)
  - Expected outcome documentation
- Integration tests should use `check_ndu_status()` to skip if NDU not available

**Verification:**
- Test 1.2-INT-003 passes without NDU (basic bridge validation): `pytest tests/stories/1.2/integration/test_1_2_int_003.py -v`
- Tests 1.2-INT-005 and 1.2-INT-006 require Windows + NDU:
  - `pytest tests/stories/1.2/integration/test_1_2_int_005.py -v`
  - `pytest tests/stories/1.2/integration/test_1_2_int_006.py -v`
- Schema validation confirms DataFrame matches `docs/architecture/data-models.md` specification

---

## Commit 6: test(data): add integration tests for advanced features

**Tests:** 1.2-INT-002, 1.2-INT-004, 1.2-INT-007
**ACs:** 1, 2, 3
**Priority:** P1/P2

**Setup:**
- Create integration tests:
  - `tests/stories/1.2/integration/test_1_2_int_002.py`: Verify norgatedata version matches requirements (1.0.74)
  - `tests/stories/1.2/integration/test_1_2_int_004.py`: Verify bridge handles concurrent requests without deadlocks
  - `tests/stories/1.2/integration/test_1_2_int_007.py`: Verify `fetch_price_data()` handles different adjustment types (CAPITAL vs TOTALRETURN)
- Add test docstrings following test standards template
- Use pytest fixtures where appropriate for test data setup

**Verification:**
- All integration tests pass (requires Windows + NDU):
  - `pytest tests/stories/1.2/integration/test_1_2_int_002.py -v`
  - `pytest tests/stories/1.2/integration/test_1_2_int_004.py -v`
  - `pytest tests/stories/1.2/integration/test_1_2_int_007.py -v`
- Concurrent request test validates no subprocess leaks
- Adjustment type test confirms TOTALRETURN differs from CAPITAL (dividend adjustments)

---

## Commit 7: docs(architecture): document Windows Python bridge architecture and usage

**Tests:** N/A (manual validation)
**ACs:** 5
**Priority:** P0

**Setup:**
- Create `docs/architecture/windows-python-bridge.md` with sections:
  - **Overview**: Why bridge is needed (WSL development + Windows NDU)
  - **Architecture**: Subprocess-based communication pattern with diagram
  - **Prerequisites**:
    - Windows environment with NDU running and authenticated
    - Windows Python 3.11+ installed and in WSL PATH
    - norgatedata 1.0.74 installed in Windows Python
  - **Usage Examples**:
    - Basic bridge usage with `execute_norgate_code()`
    - Fetching price data with `fetch_price_data()`
    - Checking NDU status with `check_ndu_status()`
  - **Error Handling**:
    - Common errors and resolutions
    - Exception hierarchy
  - **Troubleshooting**:
    - Windows Python not found → check PATH
    - NDU not running → start NDU and authenticate
    - norgatedata import error → install package in Windows Python
    - Timeout errors → check NDU responsiveness
  - **Performance Characteristics**:
    - Expected latency (~7ms per symbol from Story 1.0)
    - Timeout defaults
    - Retry behavior
  - **Testing**: How to run unit vs integration tests
  - **Limitations**: Known issues and workarounds

**Verification:**
- Manual review checklist (from test design AC5):
  - [ ] `docs/architecture/windows-python-bridge.md` exists
  - [ ] Explains subprocess pattern with code examples
  - [ ] Documents NDU prerequisites
  - [ ] Includes troubleshooting guide for common errors
  - [ ] Documents Windows Python PATH requirements
  - [ ] Provides usage examples for all public functions
- Documentation is clear, accurate, and complete

---

## Execution Order Summary

1. **Foundation Setup** (Commit 1): Exception classes for error handling
2. **Core Bridge Implementation** (Commits 2-3): Subprocess communication and helper functions with unit tests
3. **Integration Validation** (Commits 4-6): Environment validation, data retrieval, and advanced features
4. **Documentation** (Commit 7): Architecture documentation and troubleshooting guide

---

## Implementation Workflow for Each Commit

Each commit should include both tests and implementation work together:

1. **Implement**: Complete the setup steps (tests and/or implementation in whatever order makes sense)
2. **Verify**: Run the specific tests to confirm they pass
3. **Commit**: Stage tests + implementation together with the commit message

**Note:** Tests can be written before, during, or after implementation - the key is that they're committed together as one atomic unit.

---

## Dependencies Between Commits

- **Commit 2** depends on **Commit 1** (needs exception classes)
- **Commit 3** depends on **Commit 2** (needs `execute_norgate_code()`)
- **Commit 4** depends on **Commits 1-3** (needs full bridge implementation)
- **Commit 5** depends on **Commits 1-3** (needs `fetch_price_data()`)
- **Commit 6** depends on **Commits 1-3** (needs all helper functions)
- **Commit 7** can be done anytime after **Commits 1-3** (documents implemented functionality)

**Recommended execution order:** 1 → 2 → 3 → 4 → 5 → 6 → 7

---

## Test Execution Strategy

### Unit Tests (No Windows/NDU Required)
```bash
# Run all unit tests (can run in WSL without Windows Python)
pytest tests/stories/1.2/unit/ -v

# Run with coverage
pytest tests/stories/1.2/unit/ --cov=src/momo/data --cov-report=term-missing
```

### Integration Tests (Require Windows + NDU)
```bash
# Run all integration tests (requires Windows Python + NDU)
pytest tests/stories/1.2/integration/ -v

# Run specific integration test
pytest tests/stories/1.2/integration/test_1_2_int_005.py -v
```

### All Tests
```bash
# Run all Story 1.2 tests
pytest tests/stories/1.2/ -v
```

---

## Quality Gates

### Before Each Commit
- [ ] All tests in commit pass
- [ ] Type checking passes: `uv run mypy src/`
- [ ] Linting passes: `uv run ruff check .`
- [ ] Formatting applied: `uv run ruff format .`

### Before Story Completion
- [ ] All 16 test scenarios pass (11 P0 must pass)
- [ ] Unit test coverage >85% for `src/momo/data/bridge.py`
- [ ] All 6 acceptance criteria validated
- [ ] Documentation complete and reviewed
- [ ] Integration tests pass on Windows environment with NDU

---

## Risk Mitigation Mapping

This commit plan addresses all identified risks from `1.2-risk-20251204.md`:

- **TECH-001 (Critical)**: Commits 2, 4, 5 - Comprehensive subprocess testing
- **OPS-001 (High)**: Commits 2, 4 - NDU error detection and messaging
- **DATA-001 (High)**: Commits 2, 3, 5 - JSON serialization and schema validation
- **PERF-001 (Medium)**: Commits 2, 6 - Timeout handling and concurrent requests
- **TECH-002 (Medium)**: Commits 2, 4, 6 - Environment validation
- **DATA-002 (Medium)**: Commit 2 - INFO message parsing
- **SEC-001 (Low)**: Commit 2 - Code review of `execute_norgate_code()` access
- **OPS-002 (Low)**: Commits 2, 4, 7 - Clear error messages and documentation

---

**End of Atomic Commit Plan**
