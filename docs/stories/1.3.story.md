# Story 1.3: Implement Data Loading and Parquet Caching

## Status

**Draft**

## Story

**As a** developer,
**I want** to load historical price data from Norgate and cache it to local Parquet files,
**so that** backtests can run quickly and reproducibly without repeated API calls.

## Acceptance Criteria

1. `src/data/loader.py` module implements function to fetch OHLCV data for a list of tickers over a date range using norgatedata API
2. Fetched data includes adjustment factors for splits and dividends (adjusted prices)
3. Data is cached to Parquet files in `data/` directory with organized naming scheme (e.g., by universe or date range)
4. Cache loading function checks if local Parquet exists before querying Norgate API
5. Force-refresh option allows re-fetching data even if cache exists
6. Loading a cached dataset is >10x faster than API query (cache <50ms, API ~500ms for 10 symbols)
7. Cached Parquet files can be read back into pandas DataFrames with correct dtypes and index
8. Unit tests verify caching logic (write → read → validate equality)

## Tasks / Subtasks

- [ ] Implement Parquet cache manager module (AC: 3, 4, 7)
  - [ ] Create `src/momo/data/cache.py` with cache manager functions
  - [ ] Implement `get_cache_path()` helper to generate consistent file paths
  - [ ] Ensure cache directories exist (create if missing using `Path.mkdir(parents=True, exist_ok=True)`)
  - [ ] Implement `save_prices()` function to write DataFrame to Parquet with metadata
  - [ ] Implement `load_prices()` function to read Parquet and return DataFrame or None
  - [ ] Implement `invalidate()` function to force cache refresh
  - [ ] Add cache metadata tracking (timestamp, universe, date range)
  - [ ] Add type hints to all cache manager functions
  - [ ] Document DataFrame schemas in docstrings

- [ ] Implement high-level data loader orchestrator (AC: 1, 2, 4, 5, 6)
  - [ ] Create `src/momo/data/loader.py` with orchestration functions
  - [ ] Implement `load_universe()` function coordinating bridge, cache, and validation
  - [ ] Add `force_refresh` parameter to bypass cache
  - [ ] Implement single-symbol fetching using bridge.fetch_price_data() (batch optimization deferred to future story)
  - [ ] Add progress logging for multi-symbol fetches using structlog
  - [ ] Ensure TOTALRETURN adjustment type is used for dividend-adjusted prices
  - [ ] Add error handling for partial fetch failures (continue with remaining symbols)
  - [ ] Add type hints and comprehensive docstrings

- [ ] Write unit tests for cache manager (AC: 8)
  - [ ] Create test directory `tests/stories/1.3/unit/`
  - [ ] Write unit test for `save_prices()` with sample DataFrame
  - [ ] Write unit test for `load_prices()` returns None when cache missing
  - [ ] Write unit test for `load_prices()` returns DataFrame when cache exists
  - [ ] Write unit test for round-trip (save → load → validate equality)
  - [ ] Write unit test for cache path generation consistency
  - [ ] Write unit test for `invalidate()` function

- [ ] Write unit tests for data loader (AC: 8)
  - [ ] Write unit test for `load_universe()` with cache hit (mock cache.load_prices)
  - [ ] Write unit test for `load_universe()` with cache miss (mock bridge calls)
  - [ ] Write unit test for `force_refresh=True` bypasses cache
  - [ ] Write unit test for multi-symbol fetching logic (sequential single-symbol calls)
  - [ ] Write unit test for error handling with partial fetch failures

- [ ] Write integration tests (AC: 6)
  - [ ] Create test directory `tests/stories/1.3/integration/`
  - [ ] Write integration test for full cache workflow (fetch → save → load → validate)
  - [ ] Write integration test for performance comparison (cache vs API fetch)
  - [ ] Write integration test for multi-symbol fetching (sequential single-symbol calls)
  - [ ] Write integration test verifying DataFrame dtypes and index after cache round-trip

## Dev Notes

### Previous Story Insights

Story 1.2 (Integrate Norgate Data API via Windows Python Bridge) completed successfully. Key findings relevant to this story:

- **Bridge Performance**: ~57ms per symbol (50ms subprocess overhead + 7ms NDU lookup)
- **Optimization Opportunity**: Current implementation fetches one symbol at a time. Story 1.0 showed batch fetching can reduce overhead to ~7ms per symbol (82 seconds for full Russell 3000 C&P with 12,225 symbols)
- **Bridge Functions Available**: `fetch_price_data(symbol, start_date, end_date, adjustment)` and `check_ndu_status()` from `src/momo/data/bridge.py`
- **Adjustment Types**: Use TOTALRETURN for backtesting (includes dividends), CAPITAL for technical analysis
- **Error Handling**: Bridge raises `NDUNotRunningError`, `WindowsPythonNotFoundError`, `NorgateBridgeError` for various failure modes

[Source: docs/stories/1.2.story.md]

### Tech Stack (Required Versions)

| Technology | Version | Purpose |
|------------|---------|---------|
| Python | 3.13 | Primary development language |
| pandas | 2.2.x | DataFrame operations, time series |
| pyarrow | 18.x | Parquet read/write (required for pandas Parquet support) |
| structlog | 24.x | Structured logging |

[Source: docs/architecture/tech-stack.md]

### Architecture Context

#### Data Layer File Locations

From the project source tree, the data layer files are located at:
- `src/momo/data/bridge.py` - Windows Python bridge (completed in Story 1.2)
- `src/momo/data/norgate.py` - Norgate API wrappers (future story)
- `src/momo/data/cache.py` - Parquet cache manager (to be created in this story)
- `src/momo/data/loader.py` - High-level data loading orchestrator (to be created in this story)
- `src/momo/data/validation.py` - Data quality checks (future story)
- `src/momo/data/universe.py` - Point-in-time universe construction (future story)

[Source: docs/architecture/source-tree.md:36-43]

#### Cache Storage Structure

From the source tree specification:
```
data/
├── cache/
│   ├── prices/                   # Cached price Parquet files
│   ├── constituents/             # Cached constituent Parquet files (future)
│   └── universes/                # Cached universe snapshots (future)
└── results/
    └── experiments/              # Experiment JSON records (future)
```

**File Naming Convention**: `{universe}_{start_date}_{end_date}.parquet`
Example: `russell_1000_cp_2010-01-01_2020-12-31.parquet`

[Source: docs/architecture/source-tree.md:9-15]

#### Data Models

**Price Data Schema** (from Architecture Data Models):

| Attribute | Type | Description |
|-----------|------|-------------|
| `date` | `datetime64[ns]` | Trading date (DataFrame index) |
| `symbol` | `str` | Ticker symbol (e.g., "AAPL", "LEHMQ-201203") |
| `open` | `float64` | Opening price (adjusted) |
| `high` | `float64` | High price (adjusted) |
| `low` | `float64` | Low price (adjusted) |
| `close` | `float64` | Closing price (adjusted) |
| `volume` | `int64` | Trading volume |
| `unadjusted_close` | `float64` | Raw close for reference |
| `dividend` | `float64` | Dividend amount (for TOTALRETURN adjustment) |

**DataFrame Format**: MultiIndex `(date, symbol)` for price data storage in cache.

[Source: docs/architecture/data-models.md:6-22]

#### Cache Manager Component Specification

From the Components architecture document:

**Responsibility**: Cache Norgate data to local Parquet files for offline operation and fast iteration.

**Key Interfaces**:
```python
def save_prices(df: pd.DataFrame, universe: str) -> Path
def load_prices(universe: str) -> pd.DataFrame | None
def save_constituents(df: pd.DataFrame, index: str) -> Path  # Future story
def load_constituents(index: str) -> pd.DataFrame | None      # Future story
def invalidate(universe: str) -> None
def get_cache_info() -> dict[str, CacheMetadata]              # Optional for this story
```

**Dependencies**: None (uses filesystem)

[Source: docs/architecture/components.md:33-48]

#### Data Loading Orchestrator Component Specification

From the Components architecture document:

**Responsibility**: Coordinate fetching data from Norgate (via bridge) or cache, with validation.

**Key Interfaces**:
```python
def load_universe(universe: str, start_date: date, end_date: date,
                  force_refresh: bool = False) -> pd.DataFrame
def load_constituents(index: str, start_date: date, end_date: date,
                      force_refresh: bool = False) -> pd.DataFrame  # Future story
def refresh_cache(universe: str, start_date: date, end_date: date) -> None  # Optional for this story
```

**Dependencies**: `bridge.py` (from Story 1.2), `cache.py` (this story), `validation.py` (future story - skip for now)

[Source: docs/architecture/components.md:49-63]

### Coding Standards

**Critical Rules** to follow:

1. **Always Use structlog** - Never `print()` or stdlib `logging`
2. **DataFrame Schema Documentation** - Document columns and dtypes in docstrings
3. **Explicit Date Handling** - Use `datetime.date`, not strings
4. **No Magic Numbers** - Name all constants or use config
5. **Validate at Layer Boundaries** - Data layer validates; inner layers trust input
6. **No Relative Imports Across Layers** - Use absolute imports from `momo`

**Naming Conventions**:
- DataFrame variables: Suffix `_df` (e.g., `prices_df`)
- Series variables: Suffix `_s` (e.g., `returns_s`)
- Date variables: Suffix `_date` (e.g., `start_date`)

[Source: docs/architecture/coding-standards.md:24-36]

### Exception Handling

Use custom exceptions from `src/momo/utils/exceptions.py` (created in Story 1.2):

```python
from momo.utils.exceptions import BridgeError, NorgateBridgeError

# Add new exception for this story:
class CacheError(DataError):
    """Cache operation errors."""
    pass
```

[Source: Inferred from docs/architecture/coding-standards.md:52 and Story 1.2 implementation]

### Performance Optimization Notes

From Story 1.0 findings:
- **Current**: ~57ms per symbol (subprocess overhead dominates)
- **Optimization Opportunity**: Batch fetch multiple symbols in one subprocess call
- **Target**: Reduce to ~7ms per symbol for batch operations
- **Full Russell 3000 C&P**: 12,225 symbols × 7ms = ~82 seconds (vs ~12 minutes with current implementation)

**Batch Fetching Strategy (DEFERRED TO FUTURE STORY)**:
```python
# Instead of calling fetch_price_data() 100 times (5.7 seconds)
# Construct one subprocess call that fetches all 100 symbols (0.7 seconds)
# Serialize results via JSON and parse in WSL Python
```

**Story 1.3 Scope**: This story implements single-symbol fetching using the existing `bridge.fetch_price_data()` function. Batch fetching optimization will be implemented in a future performance optimization story.

[Source: docs/research/norgate-api-exploration.md]

### Parquet Best Practices

**Engine**: Use `pyarrow` engine (already in dependencies)
**Compression**: Use `snappy` compression (good balance of speed and size)
**Index**: Preserve MultiIndex `(date, symbol)` when saving/loading

**Metadata Storage**: Store cache metadata using Parquet custom metadata via pandas `metadata` parameter:

```python
# Save with metadata
metadata = {
    'universe': 'russell_1000_cp',
    'start_date': '2010-01-01',
    'end_date': '2020-12-31',
    'created_at': datetime.now(timezone.utc).isoformat(),
    'momo_version': '0.1.0'
}
df.to_parquet(path, engine='pyarrow', compression='snappy', metadata=metadata)

# Load
df = pd.read_parquet(path, engine='pyarrow')

# Access metadata (if needed)
import pyarrow.parquet as pq
parquet_file = pq.ParquetFile(path)
stored_metadata = parquet_file.schema_arrow.metadata
```

[Source: Standard pandas/pyarrow practices for financial time series]

### Project Structure Notes

**Alignment**: Story requirements align with architecture documents. The cache and loader modules fit into the data layer as defined in source-tree.md.

**Key Points**:
- Cache manager is a foundational component for all future stories requiring data
- Loader orchestrates bridge, cache, and will coordinate with validation (Story 1.4)
- Future stories (1.4, 1.5) will extend the cache manager for constituents and universes

[Source: docs/architecture/source-tree.md]

## Testing

**Test File Location**:
- Story-based location: `tests/stories/1.3/`
- Unit tests: `tests/stories/1.3/unit/`
- Integration tests: `tests/stories/1.3/integration/`

**Test Standards**:
- File naming: `test_1_3_unit_001.py`, `test_1_3_int_001.py`, etc.
- Test function naming: `test_1_3_unit_001()`, `test_1_3_int_001()`, etc.
- One test per file principle (deterministic AI agent mapping)
- Include docstring header with Test ID, Story, Priority, Test Level, Risk Coverage

**Testing Frameworks and Patterns**:
- Framework: pytest 8.x
- Mocking: unittest.mock for cache file I/O and bridge calls
- Integration tests require actual file system operations (but not NDU)
- Use `tmp_path` fixture for temporary cache directories in tests

**Test Execution**:
```bash
# Run all Story 1.3 tests
pytest tests/stories/1.3/ -v

# Run only unit tests (no file I/O)
pytest tests/stories/1.3/unit/ -v

# Run only integration tests (actual file I/O)
pytest tests/stories/1.3/integration/ -v

# Run with coverage
pytest tests/stories/1.3/ --cov=src/momo/data --cov-report=term-missing
```

**Specific Test Requirements**:

**Unit Tests** (tests/stories/1.3/unit/):
1. **Cache Manager Tests**:
   - Verify `save_prices()` writes Parquet with correct schema (mock file I/O)
   - Verify `load_prices()` returns None when cache missing (mock file system)
   - Verify `load_prices()` returns DataFrame when cache exists (mock file I/O)
   - Verify round-trip equality (save → load → compare DataFrames)
   - Verify cache path generation follows naming convention
   - Verify `invalidate()` function removes cache files

2. **Data Loader Tests**:
   - Verify `load_universe()` with cache hit (mock cache.load_prices returns DataFrame)
   - Verify `load_universe()` with cache miss (mock cache returns None, then mock bridge calls)
   - Verify `force_refresh=True` bypasses cache and calls bridge
   - Verify multi-symbol fetching using sequential single-symbol bridge calls
   - Verify error handling with partial fetch failures

**Integration Tests** (tests/stories/1.3/integration/):
1. **Full Cache Workflow**: Fetch data via bridge → save to cache → load from cache → validate DataFrame equality
2. **Performance Comparison**: Measure cache load time vs bridge fetch time (cache <50ms, API ~500ms for 10 symbols, >10x speedup)
3. **Multi-Symbol Fetching**: Fetch 10+ symbols sequentially, verify all present in cached DataFrame
4. **DataFrame Schema Validation**: Verify dtypes and index structure after cache round-trip

[Source: docs/architecture/test-strategy-and-standards.md:1-630]

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-12-04 | 1.0 | Story created from Epic 1 | Bob (Scrum Master) |
| 2025-12-04 | 1.1 | Story refinements post-review: deferred batch fetching to future story, added Parquet metadata specification, quantified AC6 performance threshold, added cache directory creation subtask | Frank (via Claude Code) |

## Dev Agent Record

### Agent Model Used

(To be filled by Dev Agent)

### Debug Log References

(To be filled by Dev Agent)

### Completion Notes

(To be filled by Dev Agent)

### File List

(To be filled by Dev Agent)

## QA Results

(To be filled by QA Agent)
